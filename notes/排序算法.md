### 冒泡排序
- 冒泡排序算法的原理如下：
    1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
    2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
    3. 针对所有的元素重复以上的步骤，除了最后一个。
    4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较

- 时间复杂度：
 1. 如果排序刚好遍历一次就能走完，那么时间复杂度为 O(n)；
 2. 如果刚好排序是反序，那么每次都要遍历n次，需要重复n次遍历，时间复杂度为 O(n²)；
 
**实现：**
```javascript
let arr = [100, 19, 3, 39, 4, 10, 2, 6, 1, 20, 8]

function maopao (arr) {
  let len = arr.length
  let tmp = ''
  arr.map(() => {
    for (let i = 0; i < len - 1; i++) {
      if (arr[i] > arr[i + 1]) {
        tmp = arr[i]
        arr[i] = arr[i + 1]
        arr[i + 1] = tmp
      }
    }
  })
  return arr
}
console.log('------>', maopao(arr)) // [1, 2, 3, 4, 6, 8, 10, 19, 20, 39, 100]
```
![](./media/1093977-20170718164306583-1106893271.gif)


### 快速排序

- 快速排序"的思想很简单，整个排序过程只需要三步：
 1. 在数据集之中，选择一个元素作为"基准"（pivot）。
 2. 所有小于"基准"的元素，都移到"基准"的左边；所有大于"基准"的元素，都移到"基准"的右边。
 3. 对"基准"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。
- 时间复杂度
 1. 排序的平均时间复杂度为O(n * log(n))
 2. 极端情况的时间复杂度就是O(n2).
 
 **实现:**
 ```javascript
 function quickSort(arr, low, high){
      let i = low //哨兵
      let j = high //哨兵
      let pivot = arr[low]
      if(i >= j) {
        return
      }
      while(i != j){
        while(i < j && arr[j] >= pivot)
          j--
        while(i < j && arr[i] <= pivot)
          i++
        if(i < j) {
          let temp = arr[j]
          arr[j] = arr[i]
          arr[i] = temp
        }
      }
      arr[low] = arr[i] //每一次排序后将基准点放在正确的位置
      arr[i] = pivot
      quickSort(arr, low, i -1)
      quickSort(arr, i + 1, high)
}
 ```
![](./media/1093977-20170720144911458-343191376.gif)


### 插入排序
 插入排序的工作原理就是将未排序数据，对已排序数据序列从后向前扫描，找到对应的位置并插入。插入排序通常采用占位的形式，空间复杂度为O(1),因此，在从后向前扫描的过程中，需要反复的把已排序的元素逐步向后挪位，为新插入元素提供插入的位置。
- 算法描述
    1. 从第一个元素开始，该元素可以被认为已经被排序
    2. 取出下一个元素，在已经排好序的序列中从后往前扫描
    3. 直到找到小于或者等于该元素的位置
    4. 将该位置后面的所有已排序的元素从后往前依次移一位
    5. 将该元素插入到该位置
    6. 重复步骤2~5
- 时间复杂度
  1. 如果排序刚好遍历一次就能走完（升序），那么时间复杂度为 O(n)；
  2. 如果是降序，那么时间复杂度为O(n²)

  **实现：**
```javascript
 function insertSort (arr) {
  let len = arr.length
  let tmp = ''
  for (let i = 1; i < len; i++) {
    tmp = arr[i]
    for (let j = i - 1; j >= 0; j--) {
      if (tmp < arr[j]) {
        arr[j + 1] = arr[j]
        arr[j] = tmp
      }
    }
  }
  return arr
}
``` 
![](./media/1093977-20170718195933005-962384786.gif)