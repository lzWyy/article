## 模块 `(module)` 模式
`Module` 模式最初被定义为一种在传统软件工程中为类提供私有和共有的封装方法。
> 在 `javascript` 中，`Module`模式用于进一步模拟类的概念，通过这种方式，能够使一个单独的对象拥有 共有 / 私有方法和变量，从而屏蔽来自全局作用域的特殊部分。产生的结果是：函数名与页面上其他脚本定义的函数冲突的可能性降低。

- `Module` 模式的实现 
```javascript
  var Car = (function () {
    // 定义私有变量
    var type = '小汽车';
    // 定义私有函数
    var year = function () {
      return '2017'
    };
    // 返回一个暴露出的共有对象
    return {
      color: 'red',  // 共有变量
      money: function (num) {  // 共有函数
        console.log('这是辆' + this.color + '的' + type + ', 需要' + num + '人民币')
      }
    }
  })();
  // 调用
  console.log(Car.color); // red
  Car.money(20000);    // 这是辆red的小汽车, 需要20000人民币
  Car.color = 'blue';  // 修改公有变量
  console.log(Car.color); // blue
  Car.money(15000);    // 这是辆blue的小汽车, 需要15000人民币
```
在上面代码中，我们定义了一个`Car`来模拟一个类， `Car`中定义一个私有变量 `type` 和一个私有方法 `year`，这两个私有成员在 `Car` 的外部是访问不到的，只能在这个函数内部被访问；通过 `return` 一个对象，将公有的变量 `color` 和共有的函数 `money` 暴露在函数外面，能够让外部修改和访问。

### `Module` 模式的优点：
  - 只有我们的模块才能享有拥有私有函数的自由。因为他们不会暴露于页面的其余部分（只会暴露我们输出的 `API`），我们认为它们是真正私有的。
  - 鉴于函数往往已申明并命名，在试图找到有哪些函数抛出异常时，这将使得在调试器中显示调用堆栈变得更容易。
### `Module` 模式的缺点：
  - 由于我们访问共有和私有成员的方式不同，当我们想改变可见性时，实际我们必须要修改每一个曾经使用过该成员的地方。